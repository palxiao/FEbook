花了两个月时间整理的前端知识手册，不敢说最全，但一定是最实用的，本文内容由浅入深，温故知新。大白话讲解，干货满满，进大厂就靠它了。

[](https://vue3js.cn/interview/vue/vue.html)

# 基础中的基础部分

## CSS盒模型
标准盒模型：box-sizing: content-box
浏览器默认的标准，元素宽度即为内容宽度。

IE盒模型：box-sizing: border-box
元素宽度为内容宽度+边距+边框，content + padding + border = width

[怪异盒模型border-box真的“一无是处”吗？](https://juejin.cn/post/7132826677469511716)

## BFC 块级格式化上下文

简单列举几个常见触发条件：

1. `float` 不为 none
2. `overflow` 不为 visible
3. `display` 为 inline-block、table-caption 或 table-cell
4. `position` 不为 static 或 relative

应用：

1. 阻止 margin 重叠
2. 阻止元素被浮动元素覆盖（以前常用于自适应两栏布局）
3. 清除内部浮动（父级元素高度塌陷问题）

总结：

BFC可以视为一种布局的手段，它的目的在于创建出一块独立区域，同时让其内部元素更好地在这片区域中布局。

由于现代 CSS 还在不断发展当中，触发 BFC 的条件可能多达十余种，包括 flex元素、grid元素内也会产生 BFC，又如 `display: flow-root` 属性值可以创建无副作用的 BFC 等。了解更多推荐阅读：[MDN - Block_formatting_context](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)

## 回流与重绘

引起元素 **大小** 或 **位置** 改变的情况，均会触发回流。反之，比如颜色样式(color、background-color、outline-style)改变，而**大小位置**不变的情况，就发生重绘 (Repaint)。

### 哪些情况会导致回流 (Reflow) 

1. 页面首次渲染
2. 浏览器窗口变化
3. 元素尺寸或位置变化（宽高、边距、边框等）
4. 元素内容发生变化（文字数量、图片大小、字体大小变化）
6. 添加删除可见的DOM节点
7. 激活css伪类（hover、active等）
8. 查询某些属性或调用某些方法（浏览器会必须回流来保证数据的准确性）

> 注意：outline-width、box-shadow、border-radius 这些属性并不会引起元素大小的改变，而是样式形状的改变，所以属于重绘。

划重点：

1. 回流必将引起重绘，重绘不一定引起回流。
2. 回流的开销比重绘更大。

进阶思考：

visibility 会引起回流还是重绘？答案是只导致重绘，因为 visibility 控制的元素**大小位置**是不变的。同理 opacity 也是一样，但 opacity 更加特殊一点，为什么呢？因为它触发的是 css3 硬件加速（GPU渲染），所以它**既不触发回流也不会触发重绘**。

常见的触发硬件加速属性有：`transform`、`opacity`、`filters`等。

### 如何减少回流重绘（性能优化）

#### HTML层面

1. 避免使用table布局
2. 在DOM树最末端改变class

#### CSS层面

1. 尽量减少使用css表达式（如：calc）
2. 避免多层内联样式
3. 将动效应用在脱离文档流的元素上（position: absolute/fixed）

#### JS层面

1. 避免用JS操作样式
2. 如无法避免多次应用样式或DOM操作，则可以先设置元素隐藏（先display:none再操作）
3. 读取元素属性时用变量缓存

DOM
事件流以及事件委托机制
W3C标准如何区分捕获和冒泡，addEventListener()后面加了Boolean参数区分
```
document.body.addEventListener('click', e => {
    console.log('捕获阶段');
}, true)

document.body.addEventListener('click', e => {
    console.log('冒泡阶段');
}, false)
```

并不是所有事件都会冒泡。如注册scroll事件，就不会触发冒泡。
mouseover & mouseenter 的区别就是后者不会冒泡，假设给ul设置了mouseover事件，在鼠标经过ul时理论应该触发一次事件，但是因为ul中还有li元素，鼠标每经过一个li元素就会冒泡到ul上的mouseover，造成多次触发，所以需要在li中多处理阻止冒泡，而mouseenter就不会出现这种问题。

什么是BOM

什么是Ajax

网络请求 GET与POST区别
GET：
没有请求体，参数大小有限制
传参局限于URL编码
参数不变时，因为浏览器协调缓存原因，可能会出现304问题（解决方法请求url带随机参数）
常用于做数据拉取

POST：
有请求体，需要设置content-type，参数大小无限制
支持多种编码格式
常用于做数据提交保存

# 浏览器基础

## 浏览器输入URL回车后经过哪些过程

0. 读取缓存看能否找到对应IP记录（将域名解析为IP地址）
1. 访问DNS服务器（将域名解析为IP地址）
2. TCP连接：三次握手
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 断开连接：TCP四次挥手

## 浏览器跨域

1. JSONP（利用script标签，前端需要定义一个回调函数接收数据，兼容性好，但只能发送get请求）
2. CORS（与服务端相关）
3. PostMessage、WebSocket（HTML5新特性）
4. Nginx反向代理（偏运维知识）
5. img标签（加分答案）

## 移动端屏幕适配

1. 利用meta标签，viewport缩放（页面拉伸模糊）
2. 响应式布局（css媒体查询）
3. rem，%，vh vw等单位（可通过postcss插件自动转化px单位）

## 浏览器缓存策略

    Cookie：有过期时间，长度限制4kb，安全问题
    SessionStorage：无过期时间，容量大，窗口关闭自动删除
    LocalStorage：持久储存，容量大
    IndexedDB：存储更大量的结构化数据

# 网络基础

## HTTP

http协议是无状态的，即同一客户端每次请求都没有任何关系。
传输方式是 URL 链接
请求方式有 8 种，常用的有 Get 和 Post 请求
消息结构包含请求头和请求体

## Get 和 Post 的区别

    Get 传输大小有限，Post 无大小限制
    Get 通过 URL 编码传输数据，Post 通过 body 传输，支持多种编码格式（两者都是明文传输，都不是安全的）
    浏览器会缓存 Get 请求，Post 则不会缓存。（在该特性下Get请求可能会出现304不更新，解决方法：加随机参数）

## 网络安全

前端如何防御XSS（跨站脚本攻击）：开启 CSP 即可，副作用是 `eval` 等方法会失效。

# CSS基础

css3常用新特性：各种选择器（如`:not()`）、圆角、阴影反射、文字特效、线性渐变、旋转，`transition`(用于过渡)，`animation`(用于动画)

## 水平垂直居中

1. flex布局（常用）
2. 父div相对定位，子div绝对定位左右`top: 50%; left:50%`，再偏移回来`transform: translate(-50%, -50%)`（绝对定位中最好用的方法，不定宽高）

## 图片居中

方法一，利用背景实现：

```
background: url(...) no-repeat center center;
background-size: contain;
```

方法二，秒杀背景方案：

```
object-fit: contain;
```

## 隐藏元素的方法

元素消失术，看好了，我只演示一次

`display: none`：结构消失，触发回流重绘
`visibility: hidden`：结构保留，占据空间，触发重绘，不可选中
`opacity: 0`：占据空间，不回流重绘，可以被选中
其它的方法：绝对定位元素，设置无限大的负边距将元素移出视图外

## 常见问题

图片不会自动撑满？

```
display：block; // 把img设置为块元素，解决
```

li与li之间看不见的空白间隔？

```
设置 font-size: 0; // 是受空格影响的，display: inline-block也会产生间隔
```

css绘制三角形原理？

```
    width: 0;
    height: 0;
    border: 50px solid transparent;
    border-top: 50px solid blue;
    
利用边框（border）属性实现，具体为设置div宽高为0，然后设置不同方向的三条边颜色为透明，剩下的边就是三角形，通过变换border宽度调整大小形状，变换剩下那条边的颜色改变三角形颜色。
```

# JS基础训练

[手写函数：call、防抖节流](https://juejin.cn/post/6972343521176977421)

[一文搞懂this、闭包、作用域，就用代码来理解](https://juejin.cn/post/6972716569407258661)

## this

this永远指向最后调用它的那个对象

[this的5种场景](https://juejin.cn/post/6972716569407258661#heading-4)

## 闭包

函数中嵌套函数。可以访问局部变量。

1. 可以用来封装私有变量
2. 实现节流函数
3. 可以作为缓存数据的策略

[JS闭包的应用场景](https://juejin.cn/post/6972716569407258661#heading-0)

## 作用域链

以当前环境向上一级一层层查找变量的过程就叫做作用域链。

## 原型链

每个函数都有 `prototype` 属性，每个函数实例对象都有一个 `__proto__` 属性，`__proto__` 指向了 `prototype`，当访问实例对象的属性或方法，会先从自身构造函数中查找，如果找不到就通过 `__proto__` 去原型中查找。

[代码理解原型链](https://juejin.cn/post/6973091550528012296#heading-10)

## call / apply / bind

共同点：都可以改变函数的作用域（箭头函数除外）

call / apply：会立即执行函数，两者区别在于传参不同

bind：不会立即执行

[如何实现一个call函数](https://juejin.cn/post/6972343521176977421#heading-0)

## new关键字

[代码模拟new一个对象发生的过程](https://juejin.cn/post/6973091550528012296#heading-9)

## 常见问题

说说数组有哪些常见方法？
```
push：末尾添加
unshift：首部添加
pop：末尾删除
shift：首部删除
concat：数组合并
join：数组元素通过连接符变成字符串
reverse：数组反转
sort：数组排序
flat：数组拍平
slice(start, end)：切割，不改变原数组，返回新数组
splice(start, length, newItem)：切割，改变数组，从指定位置开始删除，同时可插入新元素
map、foreach、filter、indexOf
```
[foreach能不能跳出循环？](https://juejin.cn/post/6971972782292729886)

如何判断数组？
```
Array.isArray([]) // ES6
Object.prototype.toString.call([]) // 返回 "[Object Array]"
```
数组去重？
```
[...new Set(arr)] // ES6
利用 indexOf() 寻找数组下标， -1 表示不存在，根据此规则来得出去重的数组 // ES5
```
深浅拷贝？（首先要区分基本数据类型和引用数据类型）
```
浅拷贝：使用新变量赋值对象，它们共用引用地址

深拷贝：
1. JSON.parse(JSON.Stringify())，优点是简单，缺点是不能拷贝Function、undefined会丢失，时间对象会变成字符串。
2. 深度递归遍历

深拷贝（特殊）：Object.assign （一层是深拷贝，二层以上浅拷贝）
```
如何检测数据类型？
```
typeof 关键字：检测基本数据类型，检测不出null和Array
Object.prototype.toString.call() 方法：可检测所有类型
```

## ES6以上常用新语法/特性

1. 模板字符串
2. let、const 关键字
3. 箭头函数（没有自己的this，不能使用new命令，不能调用call）
4. class 类
5. Promise、async/await（es7开始支持）
6. export、import 模块化
7. 对象扩展（很常用，键值对重名简写，Object.assign浅拷贝）
8. 展开运算符（很常用，...用于组装数组/对象）
9. 解构赋值（可简化提取数组/对象中的值）
10. Map（与普通对象的区别在于，map键名可以是任意类型，而对象键名只能为字符串）
11. Set（元素值是唯一的，常用于数组去重）

# JS进阶

## JS继承

JS实现类继承就是下面这段代码，突出一个实用、面向未来，特点是ES6专属限定，Java狂喜版。

```js
class B extend A {
    constructor() {
        super();
    }
}
```

只会上面的只能喜提等通知了，下面聊点正经的，JS继承有哪些方法，摊开手掌✋往前一摆：

1. 原型继承
2. 构造函数继承
3. 组合继承（call / apply）
4. 寄生组合继承（最终优化版本，前面三种都是推导）
5. class继承（es6）

[JS面向对象编程，原型与继承全面解析](https://juejin.cn/post/6973091550528012296)

## 异步编程

### 事件循环 EventLoop

JS是单线程，包含了同步任务与异步任务，同步任务放入调用栈中执行，异步任务会放入**消息队列**中，等待同步任务执行完毕再取出来执行，而此时如果异步任务中仍有异步任务，则会继续放入消息队列中等待，这就是JS的事件循环。

### callback异步

会造成回调地狱，不能 try...catch 捕获，不能 return

### Promise

Promise.all()
将一个包含Promise实例的数组传入，数组内所有Promise实例执行完毕时，该方法会**返回结果数组**。

Promise.race() 
返回的是最快成功回调的一个结果。

[从零开始 - 40行代码实现一个简单Promise函数](https://juejin.cn/post/6974942495255822344)

### 宏任务与微任务

先执行微任务，执行完所有微任务才会执行下一个宏任务。

宏任务：

I/O、setTimeOut、SetInterval、requestAnimationFrame

微任务：

process.nextTick（node）、Promise.than() / catch() / finaly()

1. requestAnimationFrame：仅浏览器支持

会将每一帧中所有DOM操作集中一次渲染
特性：
重绘或回流的时间会随着浏览器的刷新频率动态改变，不能主动设置
浏览器页面不是激活状态下，会自动暂停执行

2. requestAnimationFrame

回调属于高优先级任务

3. requestIdleCallback

回调则不一定，属于低优先级任务

# 流行框架

## React与Vue的区别

R：用于构建用户界面的JavaScript库（强调函数式编程思想）
V：渐进式JavaScript框架（强调框架生态）

## React

单向数据流
Virtual DOM 控制视图
Redux状态管理器

## Vue3

Object.defineProperty -> Proxy
重构 Virtual Dom
使用 TypeScript

[Vue3一些差异对比](https://book.palxp.com/#/articles/vue)

## Vue2

### 数据双向绑定原理

采用 "**发布-订阅**" 设计模式，通过 **Object.defineProperty()** **劫持**各个属性的**setter、getter**，在数据变动时**发布消息**触发回调**更新视图**。

### Virtual Dom

Model操作，diff算法对比新旧差异，以最小代价转换DOM操作。

### 组件通信

[浅谈Vue2中的12种组件通信方式及理解](https://juejin.cn/post/6971594929470603271)

### 实战技巧

[Keep-Alive如何销毁](https://juejin.cn/post/6976814768812195854)

[用好Vue自定义指令让你的开发变得更简单](https://juejin.cn/post/6973833760429047845)

# Vue进阶

[从零开始 - 用50行代码实现一个Vuex状态管理器](https://juejin.cn/post/6975355881554870285)

[探索 Vue3 响应式数据原理 ( Proxy 与 Reflect )](https://juejin.cn/post/6974567194382303240)

# 前端性能优化

1. 减少HTTP请求
2. 使用字体图标、svg，避免png图标，如果一定要用png图标则采用css精灵图（雪碧图）
3. 图片懒加载，资源预加载
4. 不使用cookie、iframe、flash（要能说出缺点，iframe目前还有特殊应用场景）
5. 避免使用闭包（内存泄漏），避免css表达式，减少回流重绘操作（前面有详细介绍）
6. 减少第三方库的引用依赖，对大型框架类库一定要采用按需加载
7. webpack有些压缩混淆去注释的插件一定要配
8. css样式分离在单独的文件中引入（减少内联样式），因为文件可以被浏览器缓存
9. SPA应用要使用路由懒加载
10. 其它：Gzip压缩、资源CDN、服务端SSR

## 如何实现长列表

- Intersection Observer
- padding

# 常见设计模式

单例模式、工厂模式、观察者模式、适配器模式

# 算法

~~怒刷1000道力扣算法题~~

数组排序：插入 > 冒泡 > 选择





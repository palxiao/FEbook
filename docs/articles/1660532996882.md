花了两个月时间整理的前端知识手册，由浅入深，温故知新。大白话讲解，干货满满，进大厂就靠它了。

[](https://vue3js.cn/interview/vue/vue.html)

# 基础中的基础部分

## CSS盒模型
标准盒模型：box-sizing: content-box
浏览器默认的标准，元素宽度即为内容宽度。

IE盒模型：box-sizing: border-box
元素宽度为内容宽度+边距+边框，content + padding + border = width

[怪异盒模型border-box真的“一无是处”吗？](https://juejin.cn/post/7132826677469511716)

## BFC 块级格式化上下文

简单列举几个常见触发条件：

1. `float` 不为 none
2. `overflow` 不为 visible
3. `display` 为 inline-block、table-caption 或 table-cell
4. `position` 不为 static 或 relative

应用：

1. 阻止 margin 重叠
2. 阻止元素被浮动元素覆盖（以前常用于自适应两栏布局）
3. 清除内部浮动（父级元素高度塌陷问题）

总结：

BFC可以视为一种布局的手段，它的目的在于创建出一块独立区域，同时让其内部元素更好地在这片区域中布局。

由于现代 CSS 还在不断发展当中，触发 BFC 的条件可能多达十余种，包括 flex元素、grid元素内也会产生 BFC，又如 `display: flow-root` 属性值可以创建无副作用的 BFC 等。了解更多推荐阅读：[MDN - Block_formatting_context](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)

## 回流与重绘

引起元素 **大小** 或 **位置** 改变的情况，均会触发回流。反之，比如颜色样式(color、background-color、outline-style)改变，而**大小位置**不变的情况，就发生重绘 (Repaint)。

### 哪些情况会导致回流 (Reflow) 

1. 页面首次渲染
2. 浏览器窗口变化
3. 元素尺寸或位置变化（宽高、边距、边框等）
4. 元素内容发生变化（文字数量、图片大小、字体大小变化）
6. 添加删除可见的DOM节点
7. 激活css伪类（hover、active等）
8. 查询某些属性或调用某些方法（浏览器会必须回流来保证数据的准确性）

> 注意：outline-width、box-shadow、border-radius 这些属性并不会引起元素大小的改变，而是样式形状的改变，所以属于重绘。

划重点：

1. 回流必将引起重绘，重绘不一定引起回流。
2. 回流的开销比重绘更大。

进阶思考：

visibility 会引起回流还是重绘？答案是只导致重绘，因为 visibility 控制的元素**大小位置**是不变的。同理 opacity 也是一样，但 opacity 更加特殊一点，为什么呢？因为它触发的是 css3 硬件加速（GPU渲染），所以它**既不触发回流也不会触发重绘**。

常见的触发硬件加速属性有：`transform`、`opacity`、`filters`等。

### 如何减少回流重绘（性能优化）

#### HTML层面

1. 避免使用table布局
2. 在DOM树最末端改变class

#### CSS层面

1. 尽量减少使用css表达式（如：calc）
2. 避免多层内联样式
3. 将动效应用在脱离文档流的元素上（position: absolute/fixed）

#### JS层面

1. 避免用JS操作样式
2. 如无法避免多次应用样式或DOM操作，则可以先设置元素隐藏（先display:none再操作）
3. 读取元素属性时用变量缓存

## 宏任务与微任务

先执行微任务，执行完所有微任务才会执行下一个宏任务。

宏任务：

I/O、setTimeOut、SetInterval、requestAnimationFrame

微任务：

process.nextTick（node）、Promise.than() / catch() / finaly()

### requestAnimationFrame：仅浏览器支持

会将每一帧中所有DOM操作集中一次渲染
特性：
重绘或回流的时间会随着浏览器的刷新频率动态改变，不能主动设置
浏览器页面不是激活状态下，会自动暂停执行

### requestAnimationFrame

回调属于高优先级任务

### requestIdleCallback

回调则不一定，属于低优先级任务



DOM
事件流以及事件委托机制
W3C标准如何区分捕获和冒泡，addEventListener()后面加了Boolean参数区分
```
document.body.addEventListener('click', e => {
    console.log('捕获阶段');
}, true)

document.body.addEventListener('click', e => {
    console.log('冒泡阶段');
}, false)
```

并不是所有事件都会冒泡。如注册scroll事件，就不会触发冒泡。
mouseover & mouseenter 的区别就是后者不会冒泡，假设给ul设置了mouseover事件，在鼠标经过ul时理论应该触发一次事件，但是因为ul中还有li元素，鼠标每经过一个li元素就会冒泡到ul上的mouseover，造成多次触发，所以需要在li中多处理阻止冒泡，而mouseenter就不会出现这种问题。

什么是BOM

什么是Ajax

网络请求 GET与POST区别
GET：
没有请求体，参数大小有限制
传参局限于URL编码
参数不变时，因为浏览器协调缓存原因，可能会出现304问题（解决方法请求url带随机参数）
常用于做数据拉取

POST：
有请求体，需要设置content-type，参数大小无限制
支持多种编码格式
常用于做数据提交保存

# 浏览器基础

## 浏览器输入URL回车后经过哪些过程

0. 读取缓存看能否找到对应IP记录（将域名解析为IP地址）
1. 访问DNS服务器（将域名解析为IP地址）
2. TCP连接：三次握手
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 断开连接：TCP四次挥手

## 浏览器跨域

1. JSONP（利用script标签，前端需要定义一个回调函数接收数据，兼容性好，但只能发送get请求）
2. CORS（与服务端相关）
3. PostMessage、WebSocket（HTML5新特性）
4. Nginx反向代理（偏运维知识）
5. img标签（加分答案）

## 移动端屏幕适配

1. 

# JS基础训练

如何判断数组？
```
Array.isArray([]) // ES6
Object.prototype.toString.call([]) // 返回 "[Object Array]"
```
数组去重？
```
[...new Set(arr)] // ES6
利用 indexOf() 寻找数组下标， -1 表示不存在，根据此规则来得出去重的数组 // ES5
```

[手写函数：call、防抖节流](https://juejin.cn/post/6972343521176977421)

## this

this永远指向最后调用它的那个对象

## 闭包

函数中嵌套函数。
可以访问局部变量。

1. 可以用来封装私有变量
2. 实现节流函数
3. 可以作为缓存数据的策略

[this、闭包、作用域，就用代码来理解](https://juejin.cn/post/6972716569407258661)

# JS进阶

## JS继承

JS实现类继承就是下面这段代码，突出一个实用、面向未来，特点是ES6专属限定，Java狂喜版。

```js
class B extend A {
    constructor() {
        super();
    }
}
```

只会上面的只能喜提等通知了，下面聊点正经的，JS继承有哪些方法，摊开手掌✋往前一摆：

1. 原型继承
2. 构造函数继承
3. 组合继承（call / apply）
4. 寄生组合继承（最终优化版本，前面三种都是推导）
5. class继承（es6）

[JS面向对象编程，原型与继承全面解析](https://juejin.cn/post/6973091550528012296)

## Promise

[从零开始 - 40行代码实现一个简单Promise函数](https://juejin.cn/post/6974942495255822344)

# 流行框架

## React与Vue的区别

R：用于构建用户界面的JavaScript库（强调函数式编程思想）
V：渐进式JavaScript框架（强调框架生态）

## React

单向数据流
Virtual DOM 控制视图
Redux状态管理器

## Vue3

Object.defineProperty -> Proxy
重构 Virtual Dom
使用 TypeScript

[Vue3一些差异对比](https://book.palxp.com/#/articles/vue)

## Vue2

### 数据双向绑定原理

采用 "**发布-订阅**" 设计模式，通过 **Object.defineProperty()** **劫持**各个属性的**setter、getter**，在数据变动时**发布消息**触发回调**更新视图**。

### Virtual Dom

Model操作，diff算法对比新旧差异，以最小代价转换DOM操作。

### 组件通信

[浅谈Vue2中的12种组件通信方式及理解](https://juejin.cn/post/6971594929470603271)

### 实战技巧

[keep-alive如何销毁](https://juejin.cn/post/6976814768812195854)

# Vue进阶

[从零开始 - 用50行代码实现一个Vuex状态管理器](https://juejin.cn/post/6975355881554870285)

[探索 Vue3 响应式数据原理 ( Proxy 与 Reflect )](https://juejin.cn/post/6974567194382303240)

# 前端性能优化


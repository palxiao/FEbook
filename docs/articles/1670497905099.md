[JS经典高频面试题库](https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=JS%E7%AF%87&topicId=271) By: 牛客网

[前端每日壹题](https://muyiy.cn/question/program/5.html) By: 木易杨前端进阶

[JavaScript 手写题，编程题 2022-2023 年集锦](https://github.com/Sunny-117/js-challenges) By: sunny-117

[大厂前端面试真题](https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblLUxZFqOA2vI2F&view=vew0lbb2R4)

## 常见高频手写题汇总

### 手写 Call 函数

### 手写深拷贝

## 进阶手写题

### 函数柯里化

### 实现 compose 函数

假设现有三个函数分别为 `a()` `b()` `c()`，请用一个函数实现 `c(b(a()))` 这种调用效果：

1. 数组出栈循环执行

```js
function compose(...funcs) {
  return function(result) {
    while(funcs.length > 0) {
      result = funcs.pop()( result )
    }
    return result
  }
}
```

结果：

```js
console.log( c(b(a(1))) === compose(c, b, a)(1) ) // true
```

2. 利用 reduce 实现

```js
function compose(...funcs) {
    return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

**面试真题**：前提条件同上，要求实现 `compose(fnArray, init)` 这样的函数，`fnArray`为abc函数数组，`init`为初始调用值。我们上面封装的 `compose` 思路不变，在此基础上封装一个变种函数即可实现：

```js
function modifyCompose(arr, init) {
    return compose(...arr)(init)
}
```

结果：

```js
console.log(modifyCompose([c, b, a], 1) === c(b(a(1)))) // true
```

### 实现 pipe 函数

其实和上面的 `compose` 是一样的，都是函数平铺组合的思想，只不过 `compose` 是**从右向左**执行函数的，如果串联的函数有顺序需求就不是很符合直观，所以 `pipe` 就是反过来**从左到右**执行而已。

```js
function pipe(...funcs) {
    return funcs.reduce((a, b) => (...args) => b(a(...args)))
}
```

结果：

```js
console.log(pipe(a, b, c)(1) === c(b(a(1)))) // true
```

### 手写 pLimit 并发控制函数

```js
const queueList = []
const max = 2
let count = 0

const pLimit = {
  enqueue: (business, ...arg) => {
    return new Promise(resolve => {
      const Fn = async () => resolve(await business(...arg))
      count >= max ? queueList.push(Fn) : pLimit.run(Fn)
    })
  },
  run: (Fn) => {
    count++
    Fn().then(() => {
      count--
      if (queueList.length > 0) {
        const Task = queueList.shift()
        pLimit.run(Task)
      }
    })
  }
}
```

验证：

```js
function asyncFun(value, delay) {
  return new Promise((resolve) => {
    console.log(' handle: ' + value);
    setTimeout(() => resolve(value), delay);
  });
}

pLimit.enqueue(asyncFun, 'a', 1000)
pLimit.enqueue(asyncFun, 'b', 2000)
pLimit.enqueue(asyncFun, 'c', 1000)
pLimit.enqueue(asyncFun, 'd', 3000)
pLimit.enqueue(asyncFun, 'e', 1000)
```

### JS 求交并差集

在工作中常用到，所以记录一下，面试应该不一定会考察。

```a = [1,2,3,4,5] b = [2]```

ES7：

```js
// 并集
let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5]
// 交集
let intersection = a.filter(v => b.includes(v)) // [2]
// 差集
let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v)) // [1,3,4,5]
```

ES6：

```js
let aSet = new Set(a)
let bSet = new Set(b)
// 并集
let union = Array.from(new Set(a.concat(b))) // [1,2,3,4,5]
// 交集
let intersection = Array.from(new Set(a.filter(v => bSet.has(v)))) // [2]
// 差集
let difference = Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v)))) // [1,3,4,5]
```

ES5：

```js
// 并集
var union = a.concat(b.filter(function(v) {
return a.indexOf(v) === -1})) // [1,2,3,4,5]
// 交集
var intersection = a.filter(function(v){ return b.indexOf(v) > -1 }) // [2]
// 差集
var difference = a.filter(function(v){ return b.indexOf(v) === -1 }).concat(b.filter(function(v){ return a.indexOf(v) === -1 })) // [1,3,4,5]
```

### 树形结构转列表

```js
const data = [
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id: 2,
                text: '节点1_1',
                parentId: 1
            }
        ]
    }
]
```

比较简单，说下思路：核心是使用递归，判断存在子集则将其传进方法中继续执行。

### 列表转树形结构

```js
const list = [
    { id: 1, name: '部门1', pid: 0 },
    { id: 2, name: '部门2', pid: 1 },
    { id: 3, name: '部门3', pid: 1 },
    { id: 4, name: '部门4', pid: 3 },
    { id: 5, name: '部门5', pid: 4 },
    { id: 6, name: '部门6', pid: 0 },
]
```

## 小试牛刀

### 编程题：提取尾部字符

输入 `["able", "age", "are"]` 输出 `"e"`
输入 `["dog", "car"]` 输出 `""`

```js
function fn(arr = []) {
    let base = ''
    try { base = arr.pop().split('').reverse() } catch {}
    const collect = new Set()
    for (text of arr) {
        const temp = text.split('').reverse()
        for (let i = 0; i < temp.length; i++) {
            if (base[i] === temp[i]) {
                collect.add(temp[i])
            } else break;
        }
    }
    return [...collect].reverse().join('')
}
```
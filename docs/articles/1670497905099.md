
## 热身：数组去重

```js
const arr = [1, 1, 'true', 'true', true, true, 1, 1, false, false, undefined, undefined, null, null, NaN, NaN, 'NaN', 0, 0, 'a', 'a', {}, {}];
console.log( unique(arr) )
```

### splice + 两层嵌套循环

```js
function unique(arr = []) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j]) {
                arr.splice(j, 1)
                j--
            }
        }
    }
    return arr
}
```

### sort 排序后循环

```js
function unique(arr = []) {
    arr = arr.sort()
    const result = []
    for (let i = 0; i < arr.length; i++) {
        arr[i] !== arr[i - 1] && result.push(arr[i])
    }
    return result
}
```

### includes / indexOf

```js
function unique(arr = []) {
    const result = []
    for (item of arr) {
        !result.includes(item) && result.push(item) // result.indexOf(item) === -1 && result.push(item)
    }
    return result
}
```

### filter + indexOf

```js
function unique(arr = []) {
    return arr.filter((item, index) => arr.indexOf(item) === index)
}
```

### reduce + includes

```js
function unique(arr = []) {
    return arr.reduce((prev, cur) => prev.includes(cur) ? prev : prev.concat(cur), [])
}
```

## 高频手写题

### 手写 Call 函数

### 手写深拷贝

### 树形结构转列表

```js
const data = [
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id: 2,
                text: '节点1_1',
                parentId: 1
            }
        ]
    }
]
```

比较简单，说下思路：核心是使用递归，判断存在子集则将其传进方法中继续执行。

### 列表转树形结构

```js
const list = [
    { id: 1, name: '部门1', pid: 0 },
    { id: 2, name: '部门2', pid: 1 },
    { id: 3, name: '部门3', pid: 1 },
    { id: 4, name: '部门4', pid: 3 },
    { id: 5, name: '部门5', pid: 4 },
    { id: 6, name: '部门6', pid: 0 },
]
```

## 进阶手写题

### 函数柯里化 currying

柯里化的作用：

1. 参数复用：当函数的某个参数经常是固定不变的，而另一个参数是变化的，这就可以使用柯里化将这个固定参数预设下来，简化代码。

2. 延迟执行：将多参数函数转换为柯里化后可以挂起，等到真正需要执行时再传递剩下的参数，这样可以实现函数执行的延迟。

3. 可组合：柯里化可以让我们组合现有的函数来创建新的函数，从而更方便构造函数管道，实现函数的组合。

柯里化的缺点：

1. 可能会带来性能上的问题，由于每次返回一个新函数，它需要在内存中分配新的空间。

2. 可能会导致一些问题的难以定位，特别是在柯里化嵌套的情况下，因为产生的新函数可能会难以理解。

### 实现 compose 函数

假设现有三个函数分别为 `a()` `b()` `c()`，请用一个函数实现 `c(b(a()))` 这种调用效果：

1. 数组出栈循环执行

```js
function compose(...funcs) {
  return function(result) {
    while(funcs.length > 0) {
      result = funcs.pop()( result )
    }
    return result
  }
}
```

结果：

```js
console.log( c(b(a(1))) === compose(c, b, a)(1) ) // true
```

2. 利用 reduce 实现

```js
function compose(...funcs) {
    return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

**面试真题**：前提条件同上，要求实现 `compose(fnArray, init)` 这样的函数，`fnArray`为abc函数数组，`init`为初始调用值。我们上面封装的 `compose` 思路不变，在此基础上封装一个变种函数即可实现：

```js
function modifyCompose(arr, init) {
    return compose(...arr)(init)
}
```

结果：

```js
console.log(modifyCompose([c, b, a], 1) === c(b(a(1)))) // true
```

### 实现 pipe 函数

其实和上面的 `compose` 是一样的，都是函数平铺组合的思想，只不过 `compose` 是**从右向左**执行函数的，如果串联的函数有顺序需求就不是很符合直观，所以 `pipe` 就是反过来**从左到右**执行而已。

```js
function pipe(...funcs) {
    return funcs.reduce((a, b) => (...args) => b(a(...args)))
}
```

结果：

```js
console.log(pipe(a, b, c)(1) === c(b(a(1)))) // true
```

### 手写 pLimit 并发控制函数

```js
const queueList = []
const max = 2
let count = 0

const pLimit = {
  enqueue: (business, ...arg) => {
    return new Promise(resolve => {
      const Fn = async () => resolve(await business(...arg))
      count >= max ? queueList.push(Fn) : pLimit.run(Fn)
    })
  },
  run: (Fn) => {
    count++
    Fn().then(() => {
      count--
      if (queueList.length > 0) {
        const Task = queueList.shift()
        pLimit.run(Task)
      }
    })
  }
}
```

验证：

```js
function asyncFun(value, delay) {
  return new Promise((resolve) => {
    console.log(' handle: ' + value);
    setTimeout(() => resolve(value), delay);
  });
}

pLimit.enqueue(asyncFun, 'a', 1000)
pLimit.enqueue(asyncFun, 'b', 2000)
pLimit.enqueue(asyncFun, 'c', 1000)
pLimit.enqueue(asyncFun, 'd', 3000)
pLimit.enqueue(asyncFun, 'e', 1000)
```

### JS 求交并差集

在工作中常用到，所以记录一下，面试应该不一定会考察。

```a = [1,2,3,4,5] b = [2]```

ES7：

```js
// 并集
let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5]
// 交集
let intersection = a.filter(v => b.includes(v)) // [2]
// 差集
let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v)) // [1,3,4,5]
```

ES6：

```js
let aSet = new Set(a)
let bSet = new Set(b)
// 并集
let union = Array.from(new Set(a.concat(b))) // [1,2,3,4,5]
// 交集
let intersection = Array.from(new Set(a.filter(v => bSet.has(v)))) // [2]
// 差集
let difference = Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v)))) // [1,3,4,5]
```

ES5：

```js
// 并集
var union = a.concat(b.filter(function(v) {
return a.indexOf(v) === -1})) // [1,2,3,4,5]
// 交集
var intersection = a.filter(function(v){ return b.indexOf(v) > -1 }) // [2]
// 差集
var difference = a.filter(function(v){ return b.indexOf(v) === -1 }).concat(b.filter(function(v){ return a.indexOf(v) === -1 })) // [1,3,4,5]
```

## 其他

### 编程题：提取尾部字符

输入 `["able", "age", "are"]` 输出 `"e"`
输入 `["dog", "car"]` 输出 `""`

```js
function fn(arr = []) {
    let base = ''
    try { base = arr.pop().split('').reverse() } catch {}
    const collect = new Set()
    for (text of arr) {
        const temp = text.split('').reverse()
        for (let i = 0; i < temp.length; i++) {
            if (base[i] === temp[i]) {
                collect.add(temp[i])
            } else break;
        }
    }
    return [...collect].reverse().join('')
}
```

### 独立作用域

```js
for (var i = 0; i < 10; i++) {
    setTimeout(function () {
        console.log(i); // 输出了 10 次 10
    }, 0);
}

for (let i = 0; i < 10; i++) {
    console.log(i); // 输出了 0 1 2 3 .... 9
}
```

改造上面的函数实现类似 `let` 这样的独立作用域：

```js
for (var i = 0; i < 10; i++) {
    (function (i) { // 独立的作用域块了
        setTimeout(function () {
            console.log(i); // 0 1 2 3 .... 9
        }, 0)
    })(i);
}
```

## 其他刊物

[JS经典高频面试题库](https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=JS%E7%AF%87&topicId=271) By: 牛客网

[前端每日壹题](https://muyiy.cn/question/program/5.html) By: 木易杨前端进阶

[JavaScript 手写题，编程题 2022-2023 年集锦](https://github.com/Sunny-117/js-challenges) By: sunny-117

[大厂前端面试真题](https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblLUxZFqOA2vI2F&view=vew0lbb2R4)
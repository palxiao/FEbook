[牛客网：JS经典高频面试题库 - 直达链接](https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=JS%E7%AF%87&topicId=271)

[木易杨前端进阶：每日壹题汇总](https://muyiy.cn/question/program/5.html)

## 常见高频手写题汇总

### 手写 Call 函数

### 手写深拷贝

## 进阶手写题

### 函数柯里化

### 实现 compose 函数

假设现有三个函数分别为 `a()` `b()` `c()`，请用一个函数实现 `c(b(a()))` 这种调用效果：

1. 数组出栈循环执行

```js
function compose(...funcs) {
  return function(result) {
    while(funcs.length > 0) {
      result = funcs.pop()( result )
    }
    return result
  }
}
```

结果：

```js
console.log( c(b(a(1))) === compose(c, b, a)(1) ) // true
```

2. 利用 reduce 实现

```js
function compose(...funcs) {
    return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

**面试真题**：前提条件同上，要求实现 `compose(fnArray, init)` 这样的函数，`fnArray`为abc函数数组，`init`为初始调用值。我们上面封装的 `compose` 思路不变，在此基础上封装一个变种函数即可实现：

```js
function modifyCompose(arr, init) {
    return compose(...arr)(init)
}
```

结果：

```js
console.log(modifyCompose([c, b, a], 1) === c(b(a(1)))) // true
```

### 实现 pipe 函数

其实和上面的 `compose` 是一样的，都是函数平铺组合的思想，只不过 `compose` 是**从右向左**执行函数的，如果串联的函数有顺序需求就不是很符合直观，所以 `pipe` 就是反过来**从左到右**执行而已。

```js
function pipe(...funcs) {
    return funcs.reduce((a, b) => (...args) => b(a(...args)))
}
```

结果：

```js
console.log(pipe(a, b, c)(1) === c(b(a(1)))) // true
```

## JS 求交并差集

应该很少见，只是自己在工作中常用到，所以记录一下，面试不一定会考察到。

ES7：

```js
// 并集
let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5]
// 交集
let intersection = a.filter(v => b.includes(v)) // [2]
// 差集
let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v)) // [1,3,4,5]
```

ES6：

```js
let aSet = new Set(a)
let bSet = new Set(b)
// 并集
let union = Array.from(new Set(a.concat(b))) // [1,2,3,4,5]
// 交集
let intersection = Array.from(new Set(a.filter(v => bSet.has(v)))) // [2]
// 差集
let difference = Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v)))) // [1,3,4,5]
```

ES5：

```js
// 并集
var union = a.concat(b.filter(function(v) {
return a.indexOf(v) === -1})) // [1,2,3,4,5]
// 交集
var intersection = a.filter(function(v){ return b.indexOf(v) > -1 }) // [2]
// 差集
var difference = a.filter(function(v){ return b.indexOf(v) === -1 }).concat(b.filter(function(v){ return a.indexOf(v) === -1 })) // [1,3,4,5]
```



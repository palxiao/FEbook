[牛客网：JS经典高频面试题库 - 直达链接](https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=&tab=JS%E7%AF%87&topicId=271)

## 常见高频手写题汇总

### 手写 Call 函数

### 手写深拷贝

## 进阶手写题

### 函数柯里化

### 实现 compose 函数

假设现有三个函数分别为 `a()` `b()` `c()`，请用一个函数实现 `c(b(a()))` 这种调用效果：

1. 数组出栈循环执行

```js
function compose(...funcs) {
  return function(result) {
    while(funcs.length > 0) {
      result = funcs.pop()( result )
    }
    return result
  }
}
```

结果：

```js
console.log( c(b(a(1))) === compose(c, b, a)(1) ) // true
```

2. 利用 reduce 实现

```js
function compose(...funcs) {
    return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

**面试真题**：前提条件同上，要求实现 `compose(fnArray, init)` 这样的函数，`fnArray`为abc函数数组，`init`为初始调用值。我们上面封装的 `compose` 思路不变，在此基础上封装一个变种函数即可实现：

```js
function modifyCompose(arr, init) {
    return compose(...arr)(init)
}
```

结果：

```js
console.log(modifyCompose([c, b, a], 1) === c(b(a(1)))) // true
```

### 实现 pipe 函数

其实和上面的 `compose` 是一样的，都是函数平铺组合的思想，只不过 `compose` 是**从右向左**执行函数的，如果串联的函数有顺序需求就不是很符合直观，所以 `pipe` 就是反过来**从左到右**执行而已。

```js
function pipe(...funcs) {
    return funcs.reduce((a, b) => (...args) => b(a(...args)))
}
```

结果：

```js
console.log(pipe([a, b, c])(1) === c(b(a(1)))) // true
```


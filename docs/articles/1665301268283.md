
## 一点微小的工作



## 瀑布流排版

瀑布流是一种经典的图片排列模式，其特点是**等宽不等高**，在保持原图比例下显示布局。

目前并没有纯**CSS**可以完美实现的瀑布流方法，常见的**多列布局**(multi-columns)实际效果非常差强人意，它会得到如下的一个竖排布局效果，在实际应用中会感觉图片是乱序排列的。

![](../images/0.2810012945735676.png)

其实用**JS**实现并不难，我们使用绝对定位布局，图片的宽度是平均分布的，只需要计算出图片的高度及`left`、`top`定位对应设置到图片元素上即可：

```html
<template>
    <div id="list">
        <div :style="{ position: 'absolute', width: `${img.w}px`, height: `${img.h}px`, left: `${img.left}px`, top: `${img.top}px` }" v-for="(img, i) in list" :index="i" :key="'img' + i">
          <img ............ />
        </div>
    </div>
</template>
```

我们用变量`columnNums`表示有多少列，`gap`表示图片间隔，容器总宽度可以由当前的**DOM**往父级查询`parentNode.offsetWidth`来获取，那么图片在布局中的宽高以及`left`值就可以计算出来了，而高度则用一个数组`columnHeights`来储存，有多少列就往里存多少个元素，随着图片列表的循环一直累加取出计算就可以得到每张图片的`top`定位了，几行代码就可以搞定：

```js
let columnNums = 2 // 有多少列
const gap = 8 // 图片之间的间隔
const columnHeights = [] // 列的高度

function waterfall(data) { // data为图片数组
  const columnHeights: any = [] // 列的高度
  let { offsetWidth: pW } = document.getElementById('list').parentNode.offsetWidth
  pW -= gap * (columnNums - 1) // 总体宽度数值等于减去间隔
  const newList = JSON.parse(JSON.stringify(data))
  for (let i = 0; i < newList.length; i++) {
    let index = i % columnNums
    const item = newList[i]
    const ratio = pW / columnNums / item.width
    item.w = pW / columnNums
    item.h = item.height * ratio
    item.left = index * (pW / columnNums + gap)
    item.top = columnHeights[index] + gap || 0
    columnHeights[index] = isNaN(columnHeights[index]) ? item.h : item.h + columnHeights[index] + gap
  }
  return newList
}
```

| 两列： | 改成三列： |
| --- | --- |
| ![](../images/0.9444765612071566.png) | ![](../images/0.8661529326835606.png) |

这时候虽然瀑布流的样式已经出来了，但拉到列表底部就会发现空白问题：

![](../images/0.5087477780331877.png)

经过0.1024秒的思索，我马上发现了问题所在，上面的代码仅仅只是把图片按左右的顺序往下排列，而图片高度是不一样的，就会出现尾部瘸腿的现象，解决的办法也很简单，**找出最短的那一列**插入图片即可，我们已经将高度都存在了`columnHeights`这个数组中，通过往`Math.min()`传入**解构数组**得到最小值，再用`indexOf`得到下标，就可以知道下一张图片该插入哪一列了，修改上面方法中的最后一行代码：

```js
function waterfall(data) { // data为图片数组
  // ...........
  // columnHeights[index] = isNaN(columnHeights[index]) ? item.h : item.h + columnHeights[index] + gap
  // TODO: 上面这行代码改为找出最短列计算高度
  if (isNaN(columnHeights[index])) {
    columnHeights[index] = item.h
  } else {
    index = columnHeights.indexOf(Math.min(...columnHeights))
    item.left = index * (pW / columnNums + gap)
    item.top = columnHeights[index] + gap || 0
    columnHeights[index] = item.h + columnHeights[index] + gap
  }
}
```

以上就是实现**瀑布流**排版的全部核心代码，可以根据实际情况进行扩展，比如通过`window.onresize`监听窗口宽度变化然后改变显示列的数量重新排列等。

## 书架流排版

这个图片排版样式比较少见，但同样是等比例显示图片，区别于**瀑布流**的是图片**不等宽**，但同一行图片等高，所以我把它命名为**书架流**，看着是不是很像整齐排列在书架上的书本：

![](../images/0.14729791609720588.png)

虽然看起来似乎是**等高不等宽**，但实际上高度也不是每行都固定的，所以我们需要一个**阈值**来决定每行高度可以被允许的上限，与瀑布流一样的是，列表整体宽度是已知的，所以核心是计算每行图片的高度，我们先来看看如何实现这个算法。

抽象问题用简单的数学问题来描述往往更容易看懂。假设某行存在2张图片，它们的**实际宽高**分别为`w1`、`h1`和`w2`、`h2`，而在列表中的宽高我们则设为`w1'`、`h1'`和`w2'`、`h2'`，接着设列表总体宽高为`W`和`H`，我们的目的就是求这个`H`的值。

此时由于在同一行中图片**等高**，于是有：

`h1'`=`h2'`=`H`

又因为图片的比例不变，于是有：`w1'`/`h1'` = `w1`/`h1`，代入上面的式子可得：

`w1'`/`H` = `w1`/`h1`（同理得到另一个式子：`w2'`/`H` = `w2`/`h2`）

所以上面推导的两个式子可以得出图片在行内的**宽度**分别为：

![](../images/0.9088445081006882.png)

而总体宽度为图片宽度相加：

![](../images/0.12512274140894752.png)

代入可得到：

![](../images/0.5277533590929393.png)

到这里我们已经可以轻松推导出计算高度`H`的方法了：



## 懒加载
## 图片预览
## node生成缩略图
## 生成预载占位颜色
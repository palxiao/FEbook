
## 一点微小的工作



## 瀑布流排版

瀑布流是一种经典的图片排列模式，其特点是**等宽不等高**，在保持原图比例下显示布局。

目前并没有纯**CSS**可以完美实现的瀑布流方法，常见的**多列布局**(multi-columns)实际效果非常差强人意，它会得到如下的一个竖排布局效果，在实际应用中会感觉图片是乱序排列的。

![](../images/0.2810012945735676.png)

其实用**JS**实现并不难，我们使用绝对定位布局，图片的宽度是平均分布的，只需要计算出图片的高度及`left`、`top`定位对应设置到图片元素上即可：

```html
<template>
    <div id="list">
        <div :style="{ position: 'absolute', width: `${img.w}px`, height: `${img.h}px`, left: `${img.left}px`, top: `${img.top}px` }" v-for="(img, i) in list" :index="i" :key="'img' + i">
          <img ............ />
        </div>
    </div>
</template>
```

我们用变量`columnNums`表示有多少列，`gap`表示图片间隔，容器总宽度可以由当前的**DOM**往父级查询`parentNode.offsetWidth`来获取，那么图片在布局中的宽高以及`left`值就可以计算出来了，而高度则用一个数组`columnHeights`来储存，有多少列就往里存多少个元素，随着图片列表的循环一直累加取出计算就可以得到每张图片的`top`定位了，几行代码就可以搞定：

```js
let columnNums = 2 // 有多少列
const gap = 8 // 图片之间的间隔
const columnHeights = [] // 列的高度

function waterfall(data) { // data为图片数组
  const columnHeights: any = [] // 列的高度
  let { offsetWidth: pW } = document.getElementById('list').parentNode.offsetWidth
  pW -= gap * (columnNums - 1) // 总体宽度数值等于减去间隔
  const newList = JSON.parse(JSON.stringify(data))
  for (let i = 0; i < newList.length; i++) {
    let index = i % columnNums
    const item = newList[i]
    const ratio = pW / columnNums / item.width
    item.w = pW / columnNums
    item.h = item.height * ratio
    item.left = index * (pW / columnNums + gap)
    item.top = columnHeights[index] + gap || 0
    columnHeights[index] = isNaN(columnHeights[index]) ? item.h : item.h + columnHeights[index] + gap
  }
  return newList
}
```

| 两列： | 改成三列： |
| --- | --- |
| ![](../images/0.9444765612071566.png) | ![](../images/0.8661529326835606.png) |

这时候虽然瀑布流的样式已经出来了，但拉到列表底部就会发现瘸腿了：

![](../images/0.5087477780331877.png)

经过0.1024秒的思索，我马上发现了问题所在，上面的代码仅仅只是把图片按左右的顺序往下排列，而图片高度是不一样的，就会出现尾部空白的现象，解决的办法也很简单，每次**找出最短的那一列**插入图片即可，我们已经将高度都存在了`columnHeights`这个数组中，通过往`Math.min()`传入**解构数组**得到最小值，再用`indexOf`得到下标，就可以知道下一张图片该插入哪一列了，修改上面方法中的最后一行代码：

```js
function waterfall(data) { // data为图片数组
  // ...........
  // columnHeights[index] = isNaN(columnHeights[index]) ? item.h : item.h + columnHeights[index] + gap
  // TODO: 上面这行代码改为找出最短列计算高度
  if (isNaN(columnHeights[index])) {
    columnHeights[index] = item.h
  } else {
    index = columnHeights.indexOf(Math.min(...columnHeights))
    item.left = index * (pW / columnNums + gap)
    item.top = columnHeights[index] + gap || 0
    columnHeights[index] = item.h + columnHeights[index] + gap
  }
}
```

以上就是实现**瀑布流**排版的全部核心代码，可以根据实际情况进行扩展，比如通过`window.onresize`监听窗口宽度变化然后改变显示列的数量重新排列等。

## 书架流排版

这个图片排版样式比较少见，但同样是等比例显示图片，区别于**瀑布流**的是图片**不等宽**，但同一行图片等高，所以我把它命名为**书架流**，看着是不是很像整齐排列在书架上的书本：

![](../images/0.14729791609720588.png)

虽然看起来似乎是**等高不等宽**，但实际上高度也不是每行都固定的，因此我们需要一个**阈值**来决定每行高度可以被允许的上限，与瀑布流一样的是，列表整体宽度是已知的，所以核心是计算每行图片的高度，我们先来看看如何实现这个算法。

抽象问题用简单的数学问题来描述往往更容易看懂。假设某行存在2张图片，它们的**实际宽高**分别为`w1`、`h1`和`w2`、`h2`，而在列表中的宽高我们则设为`w1'`、`h1'`和`w2'`、`h2'`，接着设列表总体宽高为`W`和`H`，我们的目的就是求这个`H`的值。

此时由于在同一行中图片**等高**，于是有：

`h1'`=`h2'`=`H`

又因为图片的比例不变，于是有：`w1'`/`h1'` = `w1`/`h1`，代入上面的式子可得：

`w1'`/`H` = `w1`/`h1`（同理得到另一个式子：`w2'`/`H` = `w2`/`h2`）

所以上面推导的两个式子可以得出图片在行内的**宽度**分别为：

![](../images/0.9088445081006882.png)

而总体宽度为图片宽度相加：

![](../images/0.12512274140894752.png)

代入可得到：

![](../images/0.5277533590929393.png)

到这里我们已经可以轻松推导出计算高度`H`的方法了：

![](../images/0.08622294367947037.png)

上面推导过程我是在纸上完成的，回到代码中，我们可以使用**递归**来操作图片数组，得到一组计算好宽高的新数组，这里我设计了一个工厂函数`factory`以及计算函数`calculate`，计算函数核心就是利用上面的公式求图片高度，而工厂函数则是用来输出每一行的图片数组，通过判断计算的高度如果超出阈值，就继续增加这一行的图片(*一个隐藏的事实是，该行图片越多高度肯定就会越小*)，如果高度在我们设置的**阈值之内**那么就将这些图片"**打包**"返回，在`handleList`函数中会拼成一个二维数组，最后**拍平**一下数组就得到我们要的数据了：

```js
const list = JSON.parse(JSON.stringify(data)) // data为原始图片数组
const newList = await createNewArr(list)

async function createNewArr(list) {
  const standardHeight = 180 // 高度阈值
  const neatArr = [] // 整理后的数组
  function factory(cutArr) {
    return new Promise((resolve) => {
      const lineup = list.shift()
      if (!lineup) {
        resolve({ height: calculate(cutArr), list: cutArr })
        return
      }
      cutArr.push(lineup)
      const finalHeight = calculate(cutArr)
      if (finalHeight > standardHeight) { // 如果计算超出阈值，就继续加入图片
        resolve(factory(cutArr))
      } else {
        resolve({ height: finalHeight, list: cutArr })
      }
    })
  }
  function calculate(cutArr) {
    let cumulate = 0
    for (const iterator of cutArr) {
      cumulate += iterator.width / iterator.height
    }
    return (limitWidth - gap * (cutArr.length - 1)) / cumulate
  }
  async function handleList() {
    const { list: newList, height } = await factory([list.shift()])
    neatArr.push( newList.map((x) => { x.w = (x.width / x.height) * height; x.h = height; return x }))
    if (list.length > 0) {
      await handleList()
    }
  }
  await handleList()

  return neatArr.flat()
}
```

## 图片预览与查看

前面我们已经写完了图片列表的布局，接下来我们还需要点击能单独放大查看图片，并且可以支持图片**缩放**与**移动**来观察细节，实现这些操作的关键点在于 **CSS3** 中的 `transform` 变换。而实现**PC**上的点击、移动，**H5**的手势操作，则离不开DOM**事件监听**：例如鼠标移动事件对应 `mousemove`，移动端触摸移动则对应 `touchmove`，而在本项目中我们不做两套适配，将仅通过**指针事件**(`pointEvent`)进行多端**统一**的事件监听。

这一部分展开来讲篇幅不小，所以我又用**原生JS**实现了一遍并把完整的过程和思路都放在了这篇文章中：《[原生JS手写一个优雅的图片预览功能，带你吃透背后原理](https://juejin.cn/post/7160894692593401893)》

## 获取图片元数据

## 


## node生成缩略图
## 生成预载占位颜色

## 懒加载



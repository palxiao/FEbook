《你还在到处找图片预览插件吗？不如自己写一个吧！》

## 前言

本文带大家了解**图片预览**背后的原理，以及如何手写一个简单的预览。

## 打开蒙层

我们先写好一个图片列表，并绑定好点击事件，当点击图片时，通过 `document.createElement` 创建元素，然后把图片节点**克隆**进蒙层中，这一步并不难，简单实现一下。

```css
/* 图片预览样式 */
.modal {
  touch-action: none;
  user-select: none;
  position: fixed;
  z-index: 99;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.75);
}
.modal > img {
  position: absolute;
  padding: 0;
  margin: 0;
  transform: translateZ(0);
}
```

```js
// 点击时存一下相关的节点
originalEl = e.target // 原始图片
cloneEl = originalEl.cloneNode(true) // 克隆图片
originalEl.style.opacity = 0
openPreview() // 打开预览

// ........ 省略 .......

function openPreview() {
  // 创建蒙层
  const mask = document.createElement('div')
  mask.classList.add('modal')
  // 添加在body下
  document.body.appendChild(mask)
  // 注册蒙层的点击事件
  const clickFunc = function () {
    document.body.removeChild(this)
    originalEl.style.opacity = 1
    mask.removeEventListener('click', clickFunc)
  }
  mask.addEventListener("click", clickFunc)
  // 添加图片
  mask.appendChild(cloneEl)
}

// 用于修改样式，减少回流重绘
function changeStyle(el, arr) {
  const original = el.style.cssText.split(';')
  original.pop()
  el.style.cssText = original.concat(arr).join(';') + ';'
}
```

这时候我们成功添加一个**打开预览**的蒙层效果了，但克隆出来的图片位置是没有指定的，此时需要用 `getBoundingClientRect()` 方法获取一下元素相对于**可视窗口**的距离，设置为图片的**起始位置**，以覆盖在文档中图片的位置之上。

```js
// ......
// 添加图片
const { top, left } = originalEl.getBoundingClientRect()
changeStyle(cloneEl, [`left: ${left}px`, `top: ${top}px`])
mask.appendChild(cloneEl)
```

效果如下，看起来像点击高亮图片的感觉：

![](../images/0.4937476288336604.gif)

接下来我们需要实现焦点放大的效果，简单来说就是计算两点之间的位移距离作为 `translate` 偏移量，将图片偏移到**屏幕中心点**位置，然后缩放一定的比例来达到查看效果，通过 `transition` 实现过渡动画。

![](../images/0.4946000014989209.png)

中心点位置我们可以通过 `window` 下的 `innerWidth` 和 `innerHeight` 来获取浏览器**可视区域**宽高，然后除以2即可得到中心点坐标。

```js
const { innerWidth: winWidth, innerHeight: winHeight } = window

// 计算自适应屏幕的缩放值
function adaptScale() {
  const { offsetWidth: w, offsetHeight: h } = originalEl // 获取文档中图片的宽高
  let scale = 0
  scale = winWidth / w
  if (h * scale > winHeight - 80) {
    scale = (winHeight - 80) / h
  }
  return scale
}

// 移动图片到屏幕中心位置
  const originalCenterPoint = { x: offsetWidth / 2 + left, y: offsetHeight / 2 + top }
  const winCenterPoint = { x: winWidth / 2, y: winHeight / 2 }
  const offsetDistance = { left: winCenterPoint.x - originalCenterPoint.x + left, top: winCenterPoint.y - originalCenterPoint.y + top }
  const diffs = { left: ((adaptScale() - 1) * offsetWidth) / 2, top: ((adaptScale() - 1) * offsetHeight) / 2 }
  changeStyle(cloneEl, ['transition: all 0.3s', `width: ${offsetWidth * adaptScale() + 'px'}`, `transform: translate(${offsetDistance.left - left - diffs.left}px, ${offsetDistance.top - top - diffs.top}px)`])
  // 消除偏差
  setTimeout(() => {
    changeStyle(cloneEl, ['transition: all 0s', `left: 0`, `top: 0`, `transform: translate(${offsetDistance.left - diffs.left}px, ${offsetDistance.top - diffs.top}px)`])
    offset = { left: offsetDistance.left - diffs.left, top: offsetDistance.top - diffs.top } // 记录值
  }, 300)
```

这里先利用 `left` `top` 来设置克隆元素的初始位置，再通过 `translate` 偏移位置，是为了更自然地实现动画效果，在动画结束后还是统一使用 `translate` 一个变量，将绝对定位的数值归零，并且这里我并没有直接使用 `scale` 放大查看元素，而是将比例转化为**宽高**的变化，这都将减少后面做缩放等操作的计算复杂度。最终实现效果如下：

![](../images/0.9925957461956469.gif)

## 图片缩放（PC）

在PC实现图片缩放还是比较简单的，我们利用**滚轮事件**监听并改变 `scale` 值即可。其中以 `deltaY` 值的正负来判断滚轮是朝上还是朝下：

```js
let origin = 'center'
let scale = 1
// 注册事件
mask.addEventListener('mousewheel', zoom, { passive: false })

// 滚轮缩放
const zoom = (event) => {
  if (!event.deltaY) {
    return
  }
  event.preventDefault()
  origin = `${event.offsetX}px ${event.offsetY}px`
  
  if (event.deltaY < 0) {
    scale += 0.1 // 放大
  } else if (event.deltaY > 0) {
    scale >= 0.2 && (scale -= 0.1) // 缩小
  }
  changeStyle(cloneEl, ['transition: all .15s', `transform-origin: ${origin}`, `transform: translate(${offset.left + 'px'}, ${offset.top + 'px'}) scale(${scale})`])
}
```

![](../images/0.4981238932697214.gif)

> 乍一看好像没什么问题，事实上如果鼠标移动幅度很大时可能会出现不容易发现的抖动，需要消除**原点位置突然改变**带来的影响才能完全解决这个问题，期初我并未发现，后面在做移动端缩放时简直是灾难级体验，而由于PC上问题并不明显，这里先按下不表，后面会详细提到。

## 移动查看

由于
被设计来便于提供更加一致与良好的用户体验，无需关心不同用户和场景在输入硬件上的差异

> **指针** 是输入设备的硬件层抽象（比如鼠标，触摸笔，或触摸屏上的一个触摸点）。指针 能指向一个具体表面（如屏幕）上的一个（或一组）坐标，可以表示包括接触点的位置，引发事件的设备类型，接触表面受到的压力等。
> 
> [`PointerEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/PointerEvent) 接口继承了所有 [`MouseEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent "MouseEvent") 中的属性，以保障原有为鼠标事件所开发的内容能更加有效的迁移到指针事件。

## 双指缩放（移动端）










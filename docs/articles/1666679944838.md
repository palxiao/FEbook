《你还在到处找图片预览插件吗？不如自己写一个吧！》

## 前言

本文带大家了解**图片预览**背后的原理，以及如何手写一个简单的预览。

## 打开蒙层

我们先写好一个图片列表，并绑定好点击事件，当点击图片时，通过 `document.createElement` 创建元素，然后把图片节点**克隆**进蒙层中，这一步并不难，简单实现一下。

```css
/* 图片预览样式 */
.modal {
  touch-action: none;
  user-select: none;
  position: fixed;
  z-index: 99;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.75);
}
.modal > img {
  position: absolute;
  padding: 0;
  margin: 0;
  transform: translateZ(0);
}
```

```js
// 点击时存一下相关的节点
originalEl = e.target // 原始图片
cloneEl = originalEl.cloneNode(true) // 克隆图片
originalEl.style.opacity = 0
openPreview() // 打开预览

// ........ 省略 .......

function openPreview() {
  // 创建蒙层
  const mask = document.createElement('div')
  mask.classList.add('modal')
  // 添加在body下
  document.body.appendChild(mask)
  // 注册蒙层的点击事件
  const clickFunc = function () {
    document.body.removeChild(this)
    originalEl.style.opacity = 1
    mask.removeEventListener('click', clickFunc)
  }
  mask.addEventListener("click", clickFunc)
  // 添加图片
  mask.appendChild(cloneEl)
}

// 用于修改样式，减少回流重绘
function changeStyle(el, arr) {
  const original = el.style.cssText.split(';')
  original.pop()
  el.style.cssText = original.concat(arr).join(';') + ';'
}
```

这时候我们成功添加一个**打开预览**的蒙层效果了，但克隆出来的图片位置是没有指定的，此时需要用 `getBoundingClientRect()` 方法获取一下元素相对于**可视窗口**的距离，设置为图片的**起始位置**，以覆盖在文档中图片的位置之上。

```js
// ......
// 添加图片
const { top, left } = originalEl.getBoundingClientRect()
changeStyle(cloneEl, [`left: ${left}px`, `top: ${top}px`])
mask.appendChild(cloneEl)
```

效果如下，看起来像点击高亮图片的感觉：

![](../images/0.4937476288336604.gif)

接下来我们需要实现焦点放大的效果，简单来说就是计算两点之间的位移距离作为 `translate` 偏移量，将图片偏移到**屏幕中心点**位置，然后缩放一定的比例来达到查看效果，通过 `transition` 实现过渡动画。

![](../images/0.4946000014989209.png)

中心点位置我们可以通过 `window` 下的 `innerWidth` 和 `innerHeight` 来获取浏览器**可视区域**宽高，然后除以2即可得到中心点坐标。

```js
const { innerWidth: winWidth, innerHeight: winHeight } = window

// 计算自适应屏幕的缩放值
function adaptScale() {
  const { offsetWidth: w, offsetHeight: h } = originalEl // 获取文档中图片的宽高
  let scale = 0
  scale = winWidth / w
  if (h * scale > winHeight - 80) {
    scale = (winHeight - 80) / h
  }
  return scale
}

// 移动图片到屏幕中心位置
  const originalCenterPoint = { x: offsetWidth / 2 + left, y: offsetHeight / 2 + top }
  const winCenterPoint = { x: winWidth / 2, y: winHeight / 2 }
  const offsetDistance = { left: winCenterPoint.x - originalCenterPoint.x + left, top: winCenterPoint.y - originalCenterPoint.y + top }
  const diffs = { left: ((adaptScale() - 1) * offsetWidth) / 2, top: ((adaptScale() - 1) * offsetHeight) / 2 }
  changeStyle(cloneEl, ['transition: all 0.3s', `width: ${offsetWidth * adaptScale() + 'px'}`, `transform: translate(${offsetDistance.left - left - diffs.left}px, ${offsetDistance.top - top - diffs.top}px)`])
  // 消除偏差
  setTimeout(() => {
    changeStyle(cloneEl, ['transition: all 0s', `left: 0`, `top: 0`, `transform: translate(${offsetDistance.left - diffs.left}px, ${offsetDistance.top - diffs.top}px)`])
    offset = { left: offsetDistance.left - diffs.left, top: offsetDistance.top - diffs.top } // 记录值
  }, 300)
```

当然我们也可以通过定时器，最终效果如下：

![](../images/0.9925957461956469.gif)

## 图片缩放（PC）


![](../images/0.4981238932697214.gif)



## 移动查看


## 双指缩放（移动端）





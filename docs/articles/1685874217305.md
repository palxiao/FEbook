

## 什么是低代码

### 概念

低代码概念早已经火过，虽然存在着不同的声音，但是不可否认的是，许多公司依然是投入到了各类低代码应用的开发当中。

例如阿里钉钉的跨平台协作，后来衍生了宜搭这个平台，也开源了一套[通用低代码引擎 (11.5k Star)](https://lowcode-engine.cn/index)，还有字节飞书的审批流程、自动化表单等等，百度也是开源了一套低代码前端框架 [amis (14k Star)](https://aisuda.bce.baidu.com/amis/zh-CN/docs/index)。

从整体上讲，低代码能带的好处主要有以下几点：

1. 减少页面开发工作量，提升效率
2. 降低开发门槛、快速响应业务需求
3. 增加代码容错率，人工手写的内容难免会出错
4. 有利于沉淀组件，可以把低代码当做UI库来使用，灵活扩展

低代码不适合做什么：

1. 大量定制 UI，追求丰富个性化视觉效果的前端页面
2. 极为复杂或特殊的交互场景（如编辑器、绘图连线等 ）

### 低代码与零代码

零代码：业务人员通过拖拽等方式，无需编写代码，即可快速搭建各种应用。这种无代码方式只适合单点场景的应用，扩展性很差，主要的设计考虑在易用性层面。

低代码：主要面向开发人员（特别是对前端不熟悉的开发），通过自动代码生成和可视化编程，只需少量代码，即可快速搭建页面。低代码既要考虑一定的易用性，也要充分保证灵活性、可扩展性(代码增强)，这种混合开发能够基本满足具有复杂场景交互的应用。

总的来说，低代码即是把 90% 的工作交给程序去完成，而开发人员只需要负责“**走完最后的一公里路**”。

### 低代码的核心原理

以一种协议的方式定义展示页面与组件的抽象化数据，通常称之为 Schema，以 JSON 的数据格式来表示。

平台层：核心就是可视化编辑操作数据，转化(翻译)代码

业务层：引入低代码的物料（组件库），与转化的代码，然后进行渲染与增强

## 低代码实现

基于一套表单设计器进行二次开发，以便在前期就拥有画布属性配置等基本操作的能力。

以平台层为核心生成代码，接着在编辑器中增强代码，完成业务需求开发。

### 平台层（低代码引擎）

涉及到画布渲染，拖拽组件，选中态右侧属性编辑，鼠标拖拽识别、边缘探测等能力，基本功能如导入导出、撤销重做、复制删除、代码编辑等等，其次是渲染过程对 schema 的运行时适配以及性能优化，此外还有出码模块的自动生成解析器，可能涉及到语法分析和转化。

```
formDesign
├── components
│   ├── VFormDesign
│   │   ├── components
│   │   │   ├── CodeModal.vue  //  Code界面
│   │   │   ├── ComponentProps.vue  // 组件选中态右侧属性面板
│   │   │   ├── FormItemColumnProps.vue  // 表单项属性
│   │   │   ├── FormItemProps.vue  // 表单项属性
│   │   │   ├── FormNode.vue  //  拖拽节点控件
│   │   │   ├── FormNodeOperate.vue  // 节点操作复制删除控件
│   │   │   ├── FormOptions.vue  // 选项操作控件
│   │   │   ├── FormProps.vue  // 原表单属性面板，现在为全局页面配置，基本用不到
│   │   │   ├── IPhone.vue  // 手机界面的显示
│   │   │   ├── ImportJsonModal.vue  // 导入数据面板
│   │   │   ├── JsonModal.vue // 渲染JSON数据
│   │   │   ├── LayoutItem.vue  // 表单项布局
│   │   │   ├── PreviewCode.vue  // Code预览
│   │   │   ├── RuleProps.vue  // 正则校验选项组件
│   │   │   └── hooks
│   │   │       └── createCode.ts
│   │   ├── config   // 右侧控制属性面板的对应选项
│   │   │   ├── componentPropsConfig.ts
│   │   │   ├── formItemPropsConfig.ts
│   │   │   └── props
│   │   │       ├── input.ts
│   │   │       ├── ...........
│   │   ├── index.vue  // 界面入口
│   │   ├── modules // 模块
│   │   └── styles // 样式
│   ├── VFormItem // 负责渲染组件具体内容，调用的基础库是Ant-Design
│   │   ├── index.vue
│   │   └── vFormItem.vue
│   ├── VFormPreview // 预览界面，不能支持移动端，所以嵌入了iframe来模拟
│   └── index.ts  // 这里主要是用于注册全局组件，不过项目本身已全量导入
├── core   // 左侧组件选项的配置
│   ├── formItemConfig.ts
│   ├── iconConfig.ts
│   └── props
│       └── ...........
├── index.vue  //  基础入口文件
├── hooks
│   ├── useFormDesignState.ts
│   ├── useFormInstanceMethods.ts
│   └── useVFormMethods.ts
├── typings
│   ├── base-type.ts
│   ├── form-type.ts
│   └── v-form-component.ts
└── utils
    ├── index.ts
    └── message.ts
```

### 业务层

```
uv-form-created
├── comps
│   ├── BaseForm.vue
│   ├── CompItemBox.vue
│   ├── CreatForm.vue
│   ├── FormItems  // 低代码物料（基础组件库）
│   │   ├── ..........
│   │   └── index.ts
│   └── index.ts  // 自动导入所有组件
├── hooks
│   └── tools.ts
├── server // mock数据、本地代码调试等
├── page_01.vue  // 自动生成的组件
├── page_01_codeMixin.ts  //  代码增强文件
└── utils
    ├── http.ts // 封装网络请求
    ├── schemasProxy.ts // schema增强操作工具
    ├── diffObject.ts // 对比两个对象差异
    └── uiadmin2json  // 用于快速生成基于u-view的基础组件属性配置
        ├── index.js
        ├── json // 自动生成的组件翻译配置
        └── uview // 自动生成的u-view组件文档
```

**`main.ts` **自动导入物料****：

```js
import installModules from '@/uv-form-created/comps'

......
  const app = createSSRApp(App);

  installModules(app)
......
```

### 基础使用

### 从表单创建使用

### 如何封装一个低代码组件



### 如何使用自定义组件



## 最后一公里路

### 代码增强（codeMixin）

核心思想：把 Vue 组件整个抛出，通过一个 ts 文件代理组件实例来实现代码 code mixin。

优点：灵活度很高，可扩展性极强。

缺点：实现 template 的扩展不如直接引用组件方便。




